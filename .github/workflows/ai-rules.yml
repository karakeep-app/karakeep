# Universal AI Rules Workflow Template
# This template can be deployed to any repository with proper .env.tpl configuration
name: AI Rules
on:
  workflow_dispatch:
    inputs:
      assistant:
        description: override assistant
        required: false
        type: string
      mode:
        description: single or multi
        required: false
        type: string
        default: single
  repository_dispatch:
    types: [rules-updated]
  schedule:
    # Check for updates daily at 6 AM UTC (configurable via template variables)
    - cron: "0 6 * * *"

jobs:
  sync-rules:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout current repo
        uses: actions/checkout@v5

      - name: Load secrets from 1Password
        uses: 1password/load-secrets-action@v3
        with:
          export-env: true
        env:
          # Configurable 1Password vault and path
          GITHUB_PAT: op://${{ vars.AI_WORKFLOWS_SECRETS_VAULT || 'SECRETS' }}/${{ vars.AI_WORKFLOWS_GITHUB_PAT_PATH || 'Github/PAT_Claude' }}
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Checkout rules repository
        uses: actions/checkout@v5
        with:
          # Configurable source repository and reference
          repository: ${{ vars.AI_WORKFLOWS_SOURCE_REPO || 'carsaig/llm-context' }}
          ref: ${{ vars.AI_WORKFLOWS_SOURCE_REF || 'main' }}
          token: ${{ env.GITHUB_PAT }}
          path: _rules

      - name: Debug - List files in rules directory
        run: |
          echo "=== Files in _rules/${{ vars.AI_RULES_DIR || '.rules' }}/ ==="
          ls -la "_rules/${{ vars.AI_RULES_DIR || '.rules' }}/" || echo "Directory not found"
          echo "=== Looking for MEMORY.md specifically ==="
          find _rules -name "*MEMORY*" -o -name "*memory*" || echo "No memory files found"

      - name: Load env
        run: |
          set -e
          if [ -f ".env.tpl" ]; then
            echo "Using .env.tpl"
            # Filter out comments and empty lines, then load into GITHUB_ENV
            grep -E '^[A-Z_]+=.*' ".env.tpl" >> $GITHUB_ENV || echo "No valid environment variables found in .env.tpl"
          else
            echo "Missing .env.tpl"; exit 1
          fi

      - name: Resolve inputs
        id: vars
        run: |
          to_lines() { tr ' ' '\n' | sed '/^$/d'; }
          echo "MODE=${{ inputs.mode }}" >> $GITHUB_ENV
          echo "ASSISTANT=${{ inputs.assistant }}" >> $GITHUB_ENV
          # Default to env if input not set
          if [ -z "${{ inputs.assistant }}" ]; then
            echo "ASSISTANT=${AI_ASSISTANT:-cursor}" >> $GITHUB_ENV
          fi
          # Normalize lists
          echo "RULES=$(echo "${AI_RULES:-}" | to_lines | paste -sd' ' -)" >> $GITHUB_ENV
          echo "COMMON=$(echo "${AI_RULES_COMMON:-}" | to_lines | paste -sd' ' -)" >> $GITHUB_ENV
          echo "DEST=${AI_RULES_DEST:-.ai/rules}" >> $GITHUB_ENV
          echo "RULES_REPO=${AI_RULES_REPO:-${{ vars.AI_WORKFLOWS_SOURCE_REPO || 'carsaig/llm-context' }}}" >> $GITHUB_ENV
          echo "RULES_REF=${AI_RULES_REF:-${{ vars.AI_WORKFLOWS_SOURCE_REF || 'main' }}}" >> $GITHUB_ENV
          echo "RULES_DIR=${AI_RULES_DIR:-${{ vars.AI_RULES_DIR || '.rules' }}}" >> $GITHUB_ENV

          echo "=== DEBUG: Configuration ==="
          echo "ASSISTANT: ${AI_ASSISTANT:-cursor}"
          echo "RULES: ${AI_RULES:-}"
          echo "COMMON: ${AI_RULES_COMMON:-}"
          echo "RULES_DIR: ${AI_RULES_DIR:-${{ vars.AI_RULES_DIR || '.rules' }}}"

      - name: Generate for selected assistant
        run: |
          set -euo pipefail
          echo "Assistant: $ASSISTANT"
          echo "Mode: ${MODE:-single}"
          mkdir -p "$DEST"

          # collect files (case-insensitive matching) and create mapping
          FILES=""
          FILE_MAPPING=""
          for f in $COMMON $RULES; do
            rule_file="${f#.rules/}"
            found_file=""

            # Try exact match first
            if [ -f "_rules/$RULES_DIR/$rule_file" ]; then
              found_file="_rules/$RULES_DIR/$rule_file"
            else
              # Case-insensitive search
              found_file=$(find "_rules/$RULES_DIR" -iname "$rule_file" | head -1)
            fi

            if [ -n "$found_file" ]; then
              FILES="$FILES $found_file"
              FILE_MAPPING="$FILE_MAPPING $f:$found_file"
              echo "Found: $f -> $found_file"
            else
              echo "Warning: $f not found in _rules/$RULES_DIR/"
            fi
          done

          if [ -z "$FILES" ]; then
            echo "No rule files found!"; exit 1
          fi

          # Function to combine files with headers
          combine() {
            local output="$1"; shift
            echo "# Combined AI Rules" > "$output"
            echo "# Generated on $(date)" >> "$output"
            echo "" >> "$output"
            for src in "$@"; do
              echo "# === $(basename "$src") ===" >> "$output"
              cat "$src" >> "$output"
              echo "" >> "$output"
            done
          }

          case "$ASSISTANT" in
            cursor)
              if [ "${MODE:-single}" = "single" ]; then
                mkdir -p .cursor/rules
                # write individual files using base names, preserving existing
                for src in $FILES; do
                  base="$(basename "$src")"
                  target=".cursor/rules/$base"
                  if [ ! -f "$target" ]; then
                    cp -f "$src" "$target"
                    echo "added: $src -> $target"
                  else
                    echo "preserved existing: $target"
                  fi
                done
                # optional legacy combined file
                cat .cursor/rules/* > .cursorrules || true
              else
                mkdir -p "$DEST/cursor"
                combine "$DEST/cursor/rules.md" $FILES
              fi
              ;;
            zed)
              if [ "${MODE:-single}" = "single" ]; then
                combine ".rules" $FILES
              else
                mkdir -p "$DEST/zed"
                combine "$DEST/zed/rules.md" $FILES
              fi
              ;;
            windsurf)
              if [ "${MODE:-single}" = "single" ]; then
                combine ".windsurfrules" $FILES
              else
                mkdir -p "$DEST/windsurf"
                combine "$DEST/windsurf/rules.md" $FILES
              fi
              ;;
            gemini)
              if [ "${MODE:-single}" = "single" ]; then
                combine "GEMINI.md" $FILES
              else
                mkdir -p "$DEST/gemini"
                combine "$DEST/gemini/rules.md" $FILES
              fi
              ;;
            claude)
              if [ "${MODE:-single}" = "single" ]; then
                combine "CLAUDE.md" $FILES
              else
                mkdir -p "$DEST/claude"
                combine "$DEST/claude/rules.md" $FILES
              fi
              ;;
            augment)
              if [ "${MODE:-single}" = "single" ]; then
                mkdir -p .augment/rules
                # Handle case-sensitive file operations for augment
                for mapping in $FILE_MAPPING; do
                  requested="${mapping%:*}"
                  src="${mapping#*:}"
                  base="$(basename "$requested")"
                  target=".augment/rules/$base"

                  # Check if file exists with different case
                  existing_file=""
                  if [ -d ".augment/rules" ]; then
                    existing_file=$(find ".augment/rules" -iname "$base" | head -1)
                  fi

                  if [ -n "$existing_file" ] && [ "$existing_file" != "$target" ]; then
                    # File exists with different case - remove old and add new
                    rm -f "$existing_file"
                    cp -f "$src" "$target"
                    echo "updated case: $existing_file -> $target"
                  elif [ ! -f "$target" ]; then
                    # File doesn't exist - add new
                    cp -f "$src" "$target"
                    echo "added: $src -> $target"
                  else
                    # File exists with same case - update content
                    cp -f "$src" "$target"
                    echo "updated: $src -> $target"
                  fi
                done
              else
                mkdir -p "$DEST/augment"
                combine "$DEST/augment/rules.md" $FILES
              fi
              ;;
            *)
              echo "Unknown assistant: $ASSISTANT"; exit 1;;
          esac

      - name: Copy templates folder
        run: |
          set -e
          if [ -d "_rules/.templates" ]; then
            rm -rf .templates
            cp -R "_rules/.templates" ".templates"
            echo "Copied templates -> .templates/"
          else
            echo "No _rules/.templates in ${RULES_REPO}@${RULES_REF}"
          fi

      - name: Show outputs
        run: |
          echo "---- outputs ----"
          find . -maxdepth 2 -name ".rules" -o -name ".windsurfrules" -o -name ".cursorrules" -o -name "GEMINI.md" -o -name "CLAUDE.md" -o -name "AUGMENT.md" -o -path "./.cursor/rules/*" -o -path "./.ai/rules/*" | sed 's|^./||' | sort

      - name: Commit and push rules
        run: |
          # Configurable git user information
          git config --local user.email "${{ vars.AI_WORKFLOWS_GIT_EMAIL || 'action@github.com' }}"
          git config --local user.name "${{ vars.AI_WORKFLOWS_GIT_NAME || 'GitHub Action' }}"
          # Configure Git to be case-sensitive for proper case handling
          git config --local core.ignorecase false
          # Configure pull strategy to handle divergent branches
          git config --local pull.rebase false
          # Add only the generated files, not the temporary _rules checkout
          # Add each path individually to avoid errors from non-existent directories
          [ -d ".augment" ] && git add .augment/
          [ -d ".cursor" ] && git add .cursor/
          [ -d ".templates" ] && git add .templates/
          [ -f ".rules" ] && git add .rules
          [ -f ".windsurfrules" ] && git add .windsurfrules
          [ -f ".cursorrules" ] && git add .cursorrules
          [ -f "GEMINI.md" ] && git add GEMINI.md
          [ -f "CLAUDE.md" ] && git add CLAUDE.md
          [ -f "AUGMENT.md" ] && git add AUGMENT.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            CHANGED_RULES="${{ github.event.client_payload.changed_rules }}"
            if [ -n "$CHANGED_RULES" ]; then
              git commit -m "Update AI rules from central repository (${ASSISTANT}) - ${CHANGED_RULES}"
            else
              git commit -m "Update AI rules from central repository (${ASSISTANT})"
            fi
            # Handle potential push conflicts by pulling and retrying
            if ! git push; then
              echo "Push failed, pulling and retrying..."
              # Pull from the correct remote (origin) and branch (main)
              git pull origin main --no-edit
              git push
            fi
          fi
